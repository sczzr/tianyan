# 世界框架与高级架构技术实现 (v1.1)

本篇文档整合了游戏世界运行的底层框架（主循环、时间、场景、NPC AI）与高级架构（多核优化、Mod支持），是构建一个“活”的、高性能、可拓展的世界的基础。

---

## 1. 核心框架

### 1.1 游戏主控 (`GameManager.cs`)
`GameManager`是所有系统中最先启动、最后关闭的最高指挥官，以单例（Singleton）形式存在。

- **职责**:
  - **初始化**: 按顺序实例化并初始化所有其他管理器。
  - **主循环**: `_Process`作为游戏心跳，主要驱动`TimeManager`。
  - **全局状态机**: 管理`IsPaused`, `IsInMenu`等全局状态。
  - **存档/读档编排**: 作为总指挥，命令其他管理器执行各自的存盘和读盘操作。

### 1.2 游戏时间系统 (`TimeManager.cs`)
本系统是驱动世界演变的心跳。

- **核心数据**: `long TotalSecondsElapsed`，游戏世界的总流逝秒数。
- **核心逻辑**:
  - **时间流速**: `TimeScale` 控制真实时间与游戏时间的换算比例。
  - **事件广播**: 通过`OnGameHourPassed`和`OnGameDayPassed`等全局事件驱动其他系统。
  - **离线计算**: 游戏加载时，计算离线时长并调用各系统的`CatchUp(offlineSeconds)`方法。

### 1.3 地图与场景管理系统 (`SceneManager.cs`)
- **核心逻辑**: 提供统一的`ChangeScene(scenePath, spawnPointId)`接口，处理场景切换、转场动画和玩家定位。

---

## 2. 动态世界与NPC系统

### 2.1 NPC管理系统 (`NPCManager.cs`)
游戏世界的“AI导演”，负责驱动所有NPC的行为。

- **核心职责**:
  - **生命周期管理**: 从数据库加载/保存所有NPC数据。
  - **AI决策**: 周期性地为每个NPC更新其高层目标 (`current_goal`)。
  - **性能优化**: 通过**分层更新策略**确保游戏流畅。

### 2.2 分层更新策略 (Tiered Update Strategy)
- **高频更新**: 玩家视野内的NPC，每帧更新，保证动画和移动的平滑。
- **低频更新**: 玩家看不见但在同一区域的NPC，每隔数秒更新其高层决策和逻辑位置。
- **抽象模拟**: 遥远地区的NPC，只在特定时间点进行纯数值模拟（工作、修炼等）。

### 2.3 AI决策核心 (`UpdateGoal`函数)
- **触发**: 周期性（如每日清晨）或事件驱动（如完成上个目标后）。
- **逻辑**: 一个评估函数，为NPC的每个潜在新目标打分。评估项包括：
  - **`Score_Survival`**: 基于`HealthData`和需求，如寻求疗伤丹。
  - **`Score_Advancement`**: 基于`CultivationData`，如寻求突破瓶颈的丹药。
  - **`Score_Wealth`**: 基于`SpiritStones`，如寻求打工或出售物品。
  - **`Score_FollowStoryline`**: **高权重项**。如果NPC当前有激活的故事节点（由`StoryManager`管理），此项得分会极高，强制NPC去执行与故事相关的行为（如“主动寻找玩家求购筑基丹”）。

- **决策输出**: 选择得分最高的目标，设为 `npc.CurrentGoal`，并进入相应的行为状态机。

---

## 3. 高级架构设计

### 3.1 CPU多核优化方案
- **优化目标**: NPC抽象模拟、洞天离线计算等。
- **技术实现**: 使用.NET的 **任务并行库 (TPL)**，通过`Task.Run()`卸载任务，并通过`CallDeferred()`安全地将结果同步回主线程。

### 3.2 Mod (模组) 拓展支持方案
- **核心思想**: **数据驱动设计**。
- **核心原则**:
  1.  **万物皆数据**: 所有静态内容均定义在外部 `.json` 文件中。
  2.  **分层加载**: `ModLoader`按顺序加载本体和所有Mod的数据，实现新增和覆写。
  3.  **命名空间ID**: 采用`作者/Mod名:ID名`的格式避免冲突。
- **可拓展脚本**: 通过**全局事件订阅**和**组件化设计**，允许Mod作者注入自定义逻辑。
