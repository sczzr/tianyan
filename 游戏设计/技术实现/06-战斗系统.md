# 战斗系统技术实现 (v1.0)

本篇文档阐述了游戏中【战斗系统】的技术实现，该系统深度集成了【天篆系统】，将战斗表现为修士间法则与神通的直接对抗。

---

## 1. 核心概念

战斗系统为**实时制（可暂停）**。玩家和NPC通过施展预先组合好的**【神通】**来进行战斗。所有【神通】的本质都是一个或多个【天篆】的有序组合，其威力、效果和消耗由【天篆】的内在属性和施法者的修为共同决定。

---

## 2. 核心数据模型

### 2.1 神通 (`AbilityData.cs`)

【神通】是玩家和NPC在战斗中使用的技能单位。它是在“法术/神通编辑界面”中创建和保存的。

```csharp
// Represents a learned spell or ability
public class AbilityData
{
    public string ID { get; set; } // e.g., "lesser_fireball"
    public string Name { get; set; } // e.g., "小火球术"
    
    // The core of the ability: an ordered sequence of TianZhuan IDs
    public List<string> TianZhuanSequence { get; set; }
    
    // Casting properties
    public float CastTime { get; set; } // Seconds
    public float Cooldown { get; set; } // Seconds
    public float SpiritCost { get; set; } // Base spirit energy cost
}
```

### 2.2 战斗角色 (`Combatant.cs`)

一个附加到角色（玩家或NPC）或生物场景节点上的组件，用于处理战斗相关的逻辑和状态。

```csharp
using Godot;
using System.Collections.Generic;
using System.Linq;

public partial class Combatant : Node
{
    // Holds the core stats and data. Can be CharacterData or a wrapper around CreatureData.
    public ICombatantData Data { get; private set; }
    
    public List<AbilityData> Abilities { get; private set; } = new();
    
    public void SetUp(CharacterData characterData)
    {
        this.Data = new CharacterCombatantData(characterData);
        
        // Load abilities from the character's knowledge
        Abilities = characterData.Knowledge.LearnedAbilities
            .Select(id => DataManager.Instance.AllAbilities.GetValueOrDefault(id))
            .Where(a => a != null).ToList();
    }
    
    public void SetUp(CreatureData creatureData)
    {
        this.Data = new CreatureCombatantData(creatureData);

        // Load abilities from the creature's predefined list
        Abilities = creatureData.AbilityIDs
            .Select(id => DataManager.Instance.AllAbilities.GetValueOrDefault(id))
            .Where(a => a != null).ToList();
    }

    public void CastAbility(AbilityData ability, Combatant target)
    {
        // ... (rest of the logic is the same)
    }
}

// Interface to abstract Character and Creature data for combat
public interface ICombatantData 
{
    StatBlock FinalStats { get; }
    // ... other shared properties needed for combat
}
```

### 3.1 战斗管理器 (`CombatManager.cs`)
```csharp
// ...
public partial class CombatManager : Node
{
// ...
    public void ResolveAbility(Combatant caster, Combatant target, AbilityData ability)
    {
        // Now uses the interface, so it works for both Characters and Creatures
        TianZhuanEffectResult result = TianZhuanManager.Instance.CombineTianZhuans(caster.Data, target.Data, ability.TianZhuanSequence, null);
        // ...
    }
// ...
}
```

### 3.2 效果管理器 (`EffectManager.cs`)

这个系统是【天篆系统】和游戏世界之间的桥梁。它持有一个效果工厂，根据`EffectKey`来执行具体操作。

```csharp
using Godot;
using System.Collections.Generic;

public partial class EffectManager : Node
{
    public static EffectManager Instance { get; private set; }
    public override void _EnterTree() { Instance = this; }

    // A dictionary mapping effect keys to handler functions
    private Dictionary<string, System.Action<TianZhuanEffect>> _effectHandlers = new();

    public override void _Ready()
    {
        RegisterEffectHandlers();
    }

    public void ApplyEffect(TianZhuanEffect effect)
    {
        if (_effectHandlers.TryGetValue(effect.EffectKey, out var handler))
        {
            handler(effect);
        }
        else
        {
            GD.PrintErr($"Unknown effect key: {effect.EffectKey}");
        }
    }

    private void RegisterEffectHandlers()
    {
        // Example registrations
        _effectHandlers["Effect_Fire"] = HandleDirectDamageFire;
        _effectHandlers["CreateEffect_SunFire"] = HandleProjectileSunFire;
        _effectHandlers["ApplyBuff_Agility"] = HandleApplyBuff;
    }

    // --- Example Handler Implementations ---

    private void HandleDirectDamageFire(TianZhuanEffect effect)
    {
        GD.Print($"Dealing {effect.Power} fire damage to {effect.Target.Identity.Name}");
        CombatManager.Instance.CalculateAndApplyDamage(effect.Caster, effect.Target, effect.Power, DamageType.Fire);
    }

    private void HandleProjectileSunFire(TianZhuanEffect effect)
    {
        GD.Print($"Spawning a SunFire projectile towards {effect.Target.Identity.Name}");
        // var projectileScene = GD.Load<PackedScene>("res://scenes/projectiles/sunfire.tscn");
        // var projectile = projectileScene.Instantiate<Projectile>();
        // projectile.Initialize(effect.Caster, effect.Target, effect.Power);
        // GetTree().Root.AddChild(projectile);
    }

    private void HandleApplyBuff(TianZhuanEffect effect)
    {
        GD.Print($"Applying Agility buff to {effect.Target.Identity.Name}");
        // var buff = new ActiveEffect { Name = "Agility Buff", Duration = effect.Duration, ... };
        // effect.Target.ActiveEffects.Add(buff);
        // effect.Target.RecalculateStats();
    }
}
```

---

## 4. 与其他系统的集成

- **天篆系统**: 战斗系统是天篆系统最直接的应用场景。神通的威力和效果完全由天篆组合定义。
- **角色系统**: 角色的`FinalStats`（如`AttackPower`, `Defense`, `CastSpeed`）和`Comprehension`（影响天篆组合的`harmony`）直接影响战斗结果。
- **UI**: 战斗UI需要显示玩家的生命/灵力、已装备的神通及其冷却时间。
